---
title: Computer Science [컴퓨터과학]
date: 2024-11-15 08:16:30
categories: [Computer Science, Basics, Decimal, Hexadecimal, Binary]
tags: [Computer Science]
---

# 1.진법

진법은 임의의 숫자 혹은 문자를 사용하여 수를 표현하는 체계를 말합니다.  
**n진법**은 n가지(0~n-1)의 숫자와 문자를 사용하여 나타낼 수 있습니다.

## 1-2. 10진법

- 10개(0~9)의 숫자로 수를 표현합니다.
- 실생활에서는 0~9까지의 수로 각 자릿수를 나타냅니다.  
  예: 1234는 천의 자리(1000), 백의 자리(200), 십의 자리(30), 일의 자리(4)로 표현됩니다.

## 1-3. 2진법

- 컴퓨터는 10진법이 아닌 2진법을 사용합니다.
- "컴퓨터는 0과 1로 이루어졌다."라는 말은 컴퓨터에서 가장 기본적인 신호 **On/Off** 상태를 1과 0으로 표현하기 때문입니다.
- 2진법을 표현할 때 `0b`라는 접두어를 사용합니다.  
  예: 10진수 **14**를 2진법으로 표현하면 `0b1110`으로 나타냅니다.

## 1-4. 16진법

- 2진법은 수가 조금만 커져도 많은 자리수를 필요로 합니다. 그래서 2진수를 더 간편하게 표현하기 위해 **16진법**을 사용합니다.
- 16진법은 주로 **프로그래밍**, 특히 메모리 주소나 색상 코드(예: `#FF5733`)에서 많이 사용됩니다.
- 16진수는 `0x`라는 접두어를 사용하여 표현합니다.  
  예: `0b1100`은 16진법으로 `0xC`로 표현할 수 있습니다.

---

## 10진수, 2진수, 16진수 변환 표

| 10진수 | 2진수 | 16진수 |
| ------ | ----- | ------ |
| 0      | 0000  | 0      |
| 1      | 0001  | 1      |
| 2      | 0010  | 2      |
| 3      | 0011  | 3      |
| 4      | 0100  | 4      |
| 5      | 0101  | 5      |
| 6      | 0110  | 6      |
| 7      | 0111  | 7      |
| 8      | 1000  | 8      |
| 9      | 1001  | 9      |
| 10     | 1010  | A      |
| 11     | 1011  | B      |
| 12     | 1100  | C      |
| 13     | 1101  | D      |
| 14     | 1110  | E      |
| 15     | 1111  | F      |
| 16     | 10000 | 10     |

# 2. 비트와 바이트

비트와 바이트는 컴퓨터에서 데이터를 다루는 기본 개념입니다. 컴퓨터는 0과 1만으로 데이터를 표현하고 처리합니다.

## 2-1 비트와 바이트

- **비트 (bit)**: 컴퓨터에서 데이터를 표현하는 최소 단위로, 0 또는 1의 값만 가질 수 있습니다. 이는 전기 신호가 통할 경우 1, 아닐 때 0으로 나타냅니다.
- **바이트 (byte)**: 8개의 비트로 구성된 더 큰 단위입니다. 이는 메모리에 저장되는 최소 단위로, 1 바이트는 256가지(2^8) 수를 표현할 수 있습니다.
  - 10진수: 0~255
  - 2진수: 00000000~11111111
  - 16진수: 00~FF

### 예시: 10진수 60을 2진수와 16진수로 나타낸 경우

| 2진수  | 0   | 0   | 1   | 1   | 1   | 1   | 0   | 0   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| 16진수 |     |     | 3   |     |     | C   |     |     |
| 10진수 | 60  |

---

## 2-2 최상위 비트 (MSB)와 최하위 비트 (LSB)

여러 개의 비트로 구성된 데이터에서 가장 왼쪽에 있는 비트를 **최상위 비트 (MSB)**, 가장 오른쪽에 있는 비트를 **최하위 비트 (LSB)**라고 부릅니다.

| 1   | 0   | 0   | 1   | 0   | 1   | 0   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| MSB |     |     |     |     |     |     | LSB |

---

## 2-3 부호비트 (Sign Bit)

- 부호가 있는 데이터에서 **MSB**는 부호를 나타냅니다.
  - **MSB가 0**이면 양수
  - **MSB가 1**이면 음수
- **Signed 데이터**는 부호가 있는 데이터이고, **Unsigned 데이터**는 부호가 없는 양수만 나타내는 데이터입니다.

### 예시

- **부호가 있는 데이터**: `0b10010100` -> MSB가 1이므로 10진수로 **-108**
- **부호가 없는 데이터**: `0b10010100` -> MSB는 부호를 나타내지 않으며 10진수로 **148**

---

# 3. 바이트 오더링

- 2바이트 이상의 데이터는 메모리에 연속적으로 저장됩니다. 이때 데이터를 저장하는 방식을 **바이트 오더링**이라고 합니다.

## 💡 바이트 오더링과 MSB, LSB

여러 자료에서 **MSB**와 **LSB**를 이용하여 빅 엔디안과 리틀 엔디안을 설명할 때, MSB와 LSB는 **Significant Byte**를 의미합니다. 즉, 바이트 오더링은 비트 순서가 아니라 바이트 순서를 고려하는 방식입니다.

- **MSB (Most Significant Byte)**: 가장 왼쪽에 있는 바이트
- **LSB (Least Significant Byte)**: 가장 오른쪽에 있는 바이트

---

## 3-1 빅엔디안 (Big Endian)

- 가장 큰 바이트부터 메모리의 가장 왼쪽에 저장됩니다.
- 네트워크에서 데이터를 전송할 때 빅엔디안 방식을 사용합니다.
- **대표적인 예**: SPARC CPU

### 예시: `0x01234567` (2진수: `0000 0001 0010 0011 0100 0101 0110 0111`)

| 메모리 주소 | 0x100     | 0x101     | 0x102     | 0x103     |
| ----------- | --------- | --------- | --------- | --------- |
| 16진수      | 0x01      | 0x23      | 0x45      | 0x67      |
| 2진수       | 0000 0001 | 0010 0011 | 0100 0101 | 0110 0111 |

---

## 3-2 리틀엔디안 (Little Endian)

- 가장 작은 바이트부터 메모리의 가장 낮은 주소에 저장됩니다.
- **대표적인 예**: Intel의 x86, x86-64 CPU

### 예시: `0x01234567`

| 메모리 주소 | 0x100     | 0x101     | 0x102     | 0x103     |
| ----------- | --------- | --------- | --------- | --------- |
| 16진수      | 0x67      | 0x45      | 0x23      | 0x01      |
| 2진수       | 0110 0111 | 0100 0101 | 0010 0011 | 0000 0001 |

```c
#include <stdio.h>

int main() {
    unsigned int num = 0x12345678;
    unsigned char *byte = (unsigned char*)&num;

    for (int i = 0; i < sizeof(num); i++) {
        printf("%02x ", byte[i]);
    }
    printf("\n");


    return 0;
}

```

- 이 예제를 출력해보면 78 56 34 12 가 출력이 됩니다. 이러한 이유가 바로 리틀엔디안 때문입니다.

# 4.비트연산

- 피연산자를 2진수로 표현하여 비트(bit) 단위로 연산하는 것을 비트 연산이라고 합니다.
- 비트 단위로 논리연산, 시프트(shift)연산을 수행합니다.

## 4-1. 논리연산

- True(참,1) 또는 False(거짓,0)을 반환합니다.
  | 연산자 | 의미 | 결과 조건 |
  |-----------|--------------|------------------------------------------|
  | `x || y` | OR (논리합) | 둘 중 하나라도 참이면 결과는 참 |
  | `x && y` | AND (논리곱) | 둘 다 참이면 결과는 참 |
  | `!x` | NOT (부정) | 참이면 결과는 거짓, 거짓이면 결과는 참 |

## 4-2 비트연산자

- 비트 단위로 논리 연산을 수행합니다. 1은 참, 0은 거짓을 나타냅니다
  | 연산자 | 의미 | 결과 조건 |
  |-----------|---------------------------|------------------------------------------------------------|
  | `x | y` | OR (비트 논리합) | 두 비트 중 하나라도 1이면 결과는 1 |
  | `x & y` | AND (비트 논리곱) | 두 비트 모두 1이면 결과는 1 |
  | `x ^ y` | XOR (비트 배타적 논리합) | 두 비트가 같으면 결과는 0, 다르면 결과는 1 |
  | `~x` | NOT (비트 반전) | 비트가 0이면 결과는 1, 1이면 결과는 0으로 모든 비트를 반전시킴 |

## 4-3 시프트 연산자

- 비트를 특정 값만큼 왼쪽 혹은 오른쪽으로 이동합니다. n만큼 시프트한 결과는 2n으로 곱하거나 나눈 값과 같습니다.

| 연산자    | 의미                                       | 결과 조건                                                                          |
| --------- | ------------------------------------------ | ---------------------------------------------------------------------------------- |
| `x << n`  | 비트를 n만큼 왼쪽으로 이동                 | 오른쪽 빈 칸은 모두 0으로 채워지며 결과는 `x * 2^n`과 동일                         |
| `x >> n`  | (산술 시프트) 비트를 n만큼 오른쪽으로 이동 | 왼쪽 빈 칸은 가장 왼쪽 비트(MSB)와 동일한 값으로 채워지며, 결과는 `x / 2^n`과 동일 |
| `x >>> n` | (논리 시프트) 비트를 n만큼 오른쪽으로 이동 | 왼쪽 빈 칸은 모두 0으로 채워지며, 음수의 경우 부호가 유지되지 않음                 |

# 5. 인코딩,디코딩

## 5-1. 인코딩 ,디코딩

- 인코딩은 데이터를 특정한 형식으로 변환하는 작업을 말 합니다.
- 데이터 크기를 줄이거나 컴퓨터가 이해 하기 쉽게 변환할때 사용합니다.
- 디코딩은 인고딩된 데이터를 원래의 값으로 되돌리는 작업을 말 합니다.
- 암호화랑 유사하지만 암호화는 데이터의 기밀성을 목적으로 타인이 데이터를 알아보지 못 하도록 변환하기 때문에 비밀키가 있어야 원문을 복구할수 있습니다.
- 인코딩은 누구나 표준화된 방식을 사용하여 디코딩하여 원문을 구할수 있다는 점이 다릅니다.
- **인코딩은 데이터를 효율적으로 다루도록 중요한 역할을 수행합니다.**

## 5-2. 아스키 코드

- 컴퓨터는 0과 1만으로 정보를 처리하고 문자를 표현합니다. 우리가 입력하는 모든 문자가 0과 1로 변환하려면 숫자료 표현하는 작업이 필수 입니다. 이를 위한 것이 아스키 코드 입니다
- 아스키 코드는 정보교환을 위한 표준코드로 문자를 숫자로 변환하는 문자 인코딩의 표준입니다.
- 아스키 코드를 사용하여 문자를 숫자로 인코딩 하면 서로 다른 장치간 데이터 전송을 더 쉽게 수행할 수 있습니다.

- 아스키 문자 1개는 1 바이트 크기로, 7 비트로 문자를 표현하고 1 비트는 오류 체크를 위해 사용합니다.
- 따라서 2^7=128가지의 문자 표현이 가능하며, 각 문자는 0~127까지의 10진수 값을 가집니다.

  | 10진수 | 16진수 | 문자 | 10진수 | 16진수 | 문자 |
  | ------ | ------ | ---- | ------ | ------ | ---- |
  | 32     | 0x20   | 공백 | 80     | 0x50   | P    |
  | 33     | 0x21   | !    | 81     | 0x51   | Q    |
  | 34     | 0x22   | “    | 82     | 0x52   | R    |
  | 35     | 0x23   | #    | 83     | 0x53   | S    |
  | 36     | 0x24   | $    | 84     | 0x54   | T    |
  | 37     | 0x25   | %    | 85     | 0x55   | U    |
  | 38     | 0x26   | &    | 86     | 0x56   | V    |
  | 39     | 0x27   | '    | 87     | 0x57   | W    |
  | 40     | 0x28   | (    | 88     | 0x58   | X    |
  | 41     | 0x29   | )    | 89     | 0x59   | Y    |
  | 42     | 0x2A   | \*   | 90     | 0x5A   | Z    |
  | 43     | 0x2B   | +    | 91     | 0x5B   | [    |
  | 44     | 0x2C   | ,    | 92     | 0x5C   | \    |
  | 45     | 0x2D   | -    | 93     | 0x5D   | ]    |
  | 46     | 0x2E   | .    | 94     | 0x5E   | ^    |
  | 47     | 0x2F   | /    | 95     | 0x5F   | \_   |
  | 48     | 0x30   | 0    | 96     | 0x60   | `    |
  | 49     | 0x31   | 1    | 97     | 0x61   | a    |
  | 50     | 0x32   | 2    | 98     | 0x62   | b    |
  | 51     | 0x33   | 3    | 99     | 0x63   | c    |
  | 52     | 0x34   | 4    | 100    | 0x64   | d    |
  | 53     | 0x35   | 5    | 101    | 0x65   | e    |
  | 54     | 0x36   | 6    | 102    | 0x66   | f    |
  | 55     | 0x37   | 7    | 103    | 0x67   | g    |
  | 56     | 0x38   | 8    | 104    | 0x68   | h    |
  | 57     | 0x39   | 9    | 105    | 0x69   | i    |
  | 58     | 0x3A   | :    | 106    | 0x6A   | j    |
  | 59     | 0x3B   | ;    | 107    | 0x6B   | k    |
  | 60     | 0x3C   | <    | 108    | 0x6C   | l    |
  | 61     | 0x3D   | =    | 109    | 0x6D   | m    |
  | 62     | 0x3E   | >    | 110    | 0x6E   | n    |
  | 63     | 0x3F   | ?    | 111    | 0x6F   | o    |
  | 64     | 0x40   | @    | 112    | 0x70   | p    |
  | 65     | 0x41   | A    | 113    | 0x71   | q    |
  | 66     | 0x42   | B    | 114    | 0x72   | r    |
  | 67     | 0x43   | C    | 115    | 0x73   | s    |
  | 68     | 0x44   | D    | 116    | 0x74   | t    |
  | 69     | 0x45   | E    | 117    | 0x75   | u    |
  | 70     | 0x46   | F    | 118    | 0x76   | v    |
  | 71     | 0x47   | G    | 119    | 0x77   | w    |
  | 72     | 0x48   | H    | 120    | 0x78   | x    |
  | 73     | 0x49   | I    | 121    | 0x79   | y    |
  | 74     | 0x4A   | J    | 122    | 0x7A   | z    |
  | 75     | 0x4B   | K    | 123    | 0x7B   | {    |
  | 76     | 0x4C   | L    | 124    | 0x7C   |      |
  | 77     | 0x4D   | M    | 125    | 0x7D   | }    |
  | 78     | 0x4E   | N    | 126    | 0x7E   | ~    |
  | 79     | 0x4F   | O    |        |        |      |

## 5-3. 유니코드

- 아스키 코드는 알파벳 대소문자 숫자 특수문자 제어문자만 포함을 하고 있습니다.
- 초반에는 큰 문제가 되지 않았으나 다양한 언어와 문자가 나타나면서 새로운 형식이 필요해졌고 유니코드가 등장하였습니다.
- 유니코드는 영어뿐만 아니라 전세계 모든 언어의 문자에 고유한 번호를 부여하는 국제 표준 코드입니다.
- 아스키 코드보다 용량을 크게 확장하여 최대 32비트로 문자1개를 표현하여 현재 143000개 이상의 문자를 표현할 수 있습니다.
- 유니코드의 처음 128개 문자는 아스키 코드의 문자와 정확히 일치합니다. 즉, 유니코드 안에 아스키 코드가 포함된다고 볼 수 있습니다. 유니코드 값은 U+ 뒤에 16진수를 붙여 나타냅니다.
- UTF-8, UTF-16, UTF-32 등 유니코드를 사용하는 다양한 인코딩 형식이 존재합니다.
- 이는 컴퓨터가 어떤 문자를 어떻게 읽어야 하는지 미리 정해줍니다.
- UTF 뒤의 숫자는 비트를 의미합니다. 가장 일반적으로 사용되는 UTF-8은 1~4 바이트의 가변적인 크기로 문자 1개를 표현하는 방식으로, 아스키 코드와 유사합니다.

## 5-4. URL 인코딩

- 웹에서 사용되는 URL은 특정한 형식의 문자열만 사용됩니다.
- 알파벳 대소문자,숫자,그리고 일부 특수문자만 포함할 수 있습니다
- 웹 브라우저로 받은 URL 문자열을 유요한 형식으로 변환하는 것을 URL인코딩이라고 합니다.
- URL 인코딩을 통해 문자열을 인터넷으로 전송 가능한 형식으로 변환합니다.
- 이를 통해 전송 중에 문자가 수정되거나 의도와 다르게 해석되는 것을 막을 수 있습니다
- 즉 인코딩이 필요한 특수문자는 :/?#[]@!$&'()\*+,;=%공백 입니다.
- URL 인코딩은 % 기호 뒤에 해 문자의 아스키 코드 16진수 값을 붙여 나타냅니다.

  **URL에 공백이 포함되는 경우 + 기호 혹은 %20으로 변환됩니다. 여기서 %20이 URL 인코딩 결과입니다.**

## 5-5.Base64 인코딩

- Base64 인코딩은 이진 데이터를 아스키 문자로 구성된 텍스트로 변환하는 인코딩 방식입니다.
- 총 64개의 아스키 문자가 인코딩에 사용되기 때문에 64진법(Base 64)라는 의미에서 이러한 이름이 붙여졌습니다.
- 64개의 아스키 문자는 알파벳 대소문자(52자), 숫자(10자), +, / 입니다.
- Base64 인코딩은 이진 데이터를 그대로 포함할 수 없이 텍스트만 허용되는 환경에서 이진 데이터를 텍스트 형식으로 나타내기 위해 사용합니다.

## 5-6. Base64 인코딩 방식

1. 원본 이진 데이터를 비트 나열로 표현하고, 이를 6 비트씩 끊어서 묶습니다. 만약 비트의 개수가 6의 배수가 아닐 경우, 0을 뒤에 추가하여 6의 배수로 만듭니다.

2. 6 비트 묶음을 수로 변환한 뒤, base64 테이블에서 해당하는 문자를 찾아 이로 치환합니다.

3. 이렇게 치환 과정을 거친 뒤, 글자 수가 4의 배수가 되도록 문자 '='를 반복해 뒤에 추가합니다. 이를 패딩(Padding)이라고 합니다.

---

💡 패딩을 왜 넣어야 하나요?

예를 들어 여러분이 ZA 라는 두 글자를 디코딩하게 되면, 011001 000000 이라는 12개의 비트 나열로 바뀌게 되고, 이를 앞에서 8개씩 끊어 읽으면 아스키 문자 ‘d' (01100100) 이후 0000 이 남게 됩니다. 이 경우 디코딩을 하는 입장에서 뒤에 추가적인 내용이 있는데 오지 않은 것인지, 아니면 여기서 디코딩을 끝내는 것이 맞는지 알 수 없게 됩니다.
그러므로 총 비트의 개수가 8의 배수가 되게끔 패딩 문자 '='를 뒤에 붙여 이를 명확하게 하는 것입니다.

---

# 6. OS(운영체제)

- 사용자는 웹 브라우저, 엑셀, 메모장 등의 프로그램으로 원하는 작업을 수행하곤 합니다.

- 사용자를 위해 특정한 기능을 수행하는 이러한 프로그램을 응용 프로그램이라고 합니다. 이때 응용 프로그램의 동작을 수행하고, 응용 프로그램에게 시스템 자원을 할당하는 등의 복잡한 관리 작업은 사용자가 아니라 운영체제(Operating System, OS)라는 소프트웨어에 의해 이루어집니다.

- 사용자 및 응용 프로그램은 컴퓨터 하드웨어(CPU, 메모리, 입출력 장치 등)에 직접 접근하지 않습니다. 대신 운영체제가 하드웨어와 사용자/응용 프로그램 사이에서 중재자 역할을 합니다.

| 계층          | 설명                                                                              |
| ------------- | --------------------------------------------------------------------------------- |
| 사용자        | 응용 프로그램을 사용하는 주체입니다.                                              |
| 응용 프로그램 | 사용자가 실행하는 소프트웨어로, 특정 작업을 수행합니다.                           |
| 운영체제      | 응용 프로그램과 하드웨어 사이에서 자원을 관리하고 사용자 인터페이스를 제공합니다. |
| 하드웨어      | CPU, 메모리, 입출력 장치 등 물리적인 컴퓨터 구성 요소입니다.                      |

## 6-1. 운영체제가 하는 일

- 운영체제는 하드웨어 자원들을 적절히 분배하고 각 기능을 수행합니다. 수행하는 대표적인 기능들은 다음과 같습니다.
  - 실행중인 프로그램, 즉 프로세스에 CPU를 번갈아 할당해야 하는데, 이때 어떤 프로세스에 CPU를 할당할지 결정합니다. (CPU 스케줄링)
  - 메모리 공간을 각 프로세스에 분배하고 사용하는 과정을 관리합니다.
  - 컴퓨터가 입출력 장치와 정보를 주고 받는 과정을 관리합니다.

## 6-2. 커널과 셸

- 운영체제는 크게 커널과 셸로 나눌 수 있습니다. 먼저 커널(Kernel, 알맹이)은 운영체제의 핵심 기능인 하드웨어 관리를 실제로 수행하는 프로그램입니다.

- 커널은 소프트웨어와 하드웨어 간의 커뮤니케이션을 관리하며, 시스템이 부팅될 때 메모리에 올라가서 꺼질 때까지 실행됩니다.

- 셸(Shell, 껍질)은 사용자와 운영체제의 커널 사이에서 사용자가 운영체제에 명령을 내릴 수 있도록 인터페이스 역할을 합니다.
- 사용자가 셸에 명령을 입력하면, 셸이 명령어를 해석하여 커널에 요청합니다.
- 커널은 명령을 수행하며 하드웨어를 조작하고, 수행 결과를 셸에 전송합니다.

  | 계층          | 설명                                                                     |
  | ------------- | ------------------------------------------------------------------------ |
  | 사용자        | 응용 프로그램을 사용하는 주체입니다.                                     |
  | 응용 프로그램 | 사용자가 실행하는 소프트웨어로, 특정 작업을 수행합니다.                  |
  | 셸            | 사용자와 운영체제 커널 간의 인터페이스로 명령을 해석하고 실행합니다.     |
  | 커널          | 하드웨어와 응용 프로그램 사이에서 자원을 관리하고 하드웨어를 제어합니다. |
  | 하드웨어      | CPU, 메모리, 입출력 장치 등 물리적인 컴퓨터 구성 요소입니다.             |
