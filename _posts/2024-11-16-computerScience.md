---
title: Computer Science
date: 2024-11-15 08:16:30
categories: [Computer Science, Basics, Decimal, Hexadecimal, Binary]
tags: [C, Coding]
---

# 1.진법

진법은 임의의 숫자 혹은 문자를 사용하여 수를 표현하는 체계를 말합니다.  
**n진법**은 n가지(0~n-1)의 숫자와 문자를 사용하여 나타낼 수 있습니다.

## 1-2. 10진법

- 10개(0~9)의 숫자로 수를 표현합니다.
- 실생활에서는 0~9까지의 수로 각 자릿수를 나타냅니다.  
  예: 1234는 천의 자리(1000), 백의 자리(200), 십의 자리(30), 일의 자리(4)로 표현됩니다.

## 1-3. 2진법

- 컴퓨터는 10진법이 아닌 2진법을 사용합니다.
- "컴퓨터는 0과 1로 이루어졌다."라는 말은 컴퓨터에서 가장 기본적인 신호 **On/Off** 상태를 1과 0으로 표현하기 때문입니다.
- 2진법을 표현할 때 `0b`라는 접두어를 사용합니다.  
  예: 10진수 **14**를 2진법으로 표현하면 `0b1110`으로 나타냅니다.

## 1-4. 16진법

- 2진법은 수가 조금만 커져도 많은 자리수를 필요로 합니다. 그래서 2진수를 더 간편하게 표현하기 위해 **16진법**을 사용합니다.
- 16진법은 주로 **프로그래밍**, 특히 메모리 주소나 색상 코드(예: `#FF5733`)에서 많이 사용됩니다.
- 16진수는 `0x`라는 접두어를 사용하여 표현합니다.  
  예: `0b1100`은 16진법으로 `0xC`로 표현할 수 있습니다.

---

## 10진수, 2진수, 16진수 변환 표

| 10진수 | 2진수 | 16진수 |
| ------ | ----- | ------ |
| 0      | 0000  | 0      |
| 1      | 0001  | 1      |
| 2      | 0010  | 2      |
| 3      | 0011  | 3      |
| 4      | 0100  | 4      |
| 5      | 0101  | 5      |
| 6      | 0110  | 6      |
| 7      | 0111  | 7      |
| 8      | 1000  | 8      |
| 9      | 1001  | 9      |
| 10     | 1010  | A      |
| 11     | 1011  | B      |
| 12     | 1100  | C      |
| 13     | 1101  | D      |
| 14     | 1110  | E      |
| 15     | 1111  | F      |
| 16     | 10000 | 10     |

# 2. 비트와 바이트

비트와 바이트는 컴퓨터에서 데이터를 다루는 기본 개념입니다. 컴퓨터는 0과 1만으로 데이터를 표현하고 처리합니다.

## 2-1 비트와 바이트

- **비트 (bit)**: 컴퓨터에서 데이터를 표현하는 최소 단위로, 0 또는 1의 값만 가질 수 있습니다. 이는 전기 신호가 통할 경우 1, 아닐 때 0으로 나타냅니다.
- **바이트 (byte)**: 8개의 비트로 구성된 더 큰 단위입니다. 이는 메모리에 저장되는 최소 단위로, 1 바이트는 256가지(2^8) 수를 표현할 수 있습니다.
  - 10진수: 0~255
  - 2진수: 00000000~11111111
  - 16진수: 00~FF

### 예시: 10진수 60을 2진수와 16진수로 나타낸 경우

| 2진수  | 0   | 0   | 1   | 1   | 1   | 1   | 0   | 0   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- |
| 16진수 |     |     | 3   |     |     | C   |     |     |
| 10진수 | 60  |

---

## 2-2 최상위 비트 (MSB)와 최하위 비트 (LSB)

여러 개의 비트로 구성된 데이터에서 가장 왼쪽에 있는 비트를 **최상위 비트 (MSB)**, 가장 오른쪽에 있는 비트를 **최하위 비트 (LSB)**라고 부릅니다.

| 1   | 0   | 0   | 1   | 0   | 1   | 0   | 0   |
| --- | --- | --- | --- | --- | --- | --- | --- |
| MSB |     |     |     |     |     |     | LSB |

---

## 2-3 부호비트 (Sign Bit)

- 부호가 있는 데이터에서 **MSB**는 부호를 나타냅니다.
  - **MSB가 0**이면 양수
  - **MSB가 1**이면 음수
- **Signed 데이터**는 부호가 있는 데이터이고, **Unsigned 데이터**는 부호가 없는 양수만 나타내는 데이터입니다.

### 예시

- **부호가 있는 데이터**: `0b10010100` -> MSB가 1이므로 10진수로 **-108**
- **부호가 없는 데이터**: `0b10010100` -> MSB는 부호를 나타내지 않으며 10진수로 **148**

---

# 3. 바이트 오더링

- 2바이트 이상의 데이터는 메모리에 연속적으로 저장됩니다. 이때 데이터를 저장하는 방식을 **바이트 오더링**이라고 합니다.

## 💡 바이트 오더링과 MSB, LSB

여러 자료에서 **MSB**와 **LSB**를 이용하여 빅 엔디안과 리틀 엔디안을 설명할 때, MSB와 LSB는 **Significant Byte**를 의미합니다. 즉, 바이트 오더링은 비트 순서가 아니라 바이트 순서를 고려하는 방식입니다.

- **MSB (Most Significant Byte)**: 가장 왼쪽에 있는 바이트
- **LSB (Least Significant Byte)**: 가장 오른쪽에 있는 바이트

---

## 3-1 빅엔디안 (Big Endian)

- 가장 큰 바이트부터 메모리의 가장 왼쪽에 저장됩니다.
- 네트워크에서 데이터를 전송할 때 빅엔디안 방식을 사용합니다.
- **대표적인 예**: SPARC CPU

### 예시: `0x01234567` (2진수: `0000 0001 0010 0011 0100 0101 0110 0111`)

| 메모리 주소 | 0x100     | 0x101     | 0x102     | 0x103     |
| ----------- | --------- | --------- | --------- | --------- |
| 16진수      | 0x01      | 0x23      | 0x45      | 0x67      |
| 2진수       | 0000 0001 | 0010 0011 | 0100 0101 | 0110 0111 |

---

## 3-2 리틀엔디안 (Little Endian)

- 가장 작은 바이트부터 메모리의 가장 낮은 주소에 저장됩니다.
- **대표적인 예**: Intel의 x86, x86-64 CPU

### 예시: `0x01234567`

| 메모리 주소 | 0x100     | 0x101     | 0x102     | 0x103     |
| ----------- | --------- | --------- | --------- | --------- |
| 16진수      | 0x67      | 0x45      | 0x23      | 0x01      |
| 2진수       | 0110 0111 | 0100 0101 | 0010 0011 | 0000 0001 |

```c
#include <stdio.h>

int main() {
    unsigned int num = 0x12345678; 
    unsigned char *byte = (unsigned char*)&num; 

    for (int i = 0; i < sizeof(num); i++) {
        printf("%02x ", byte[i]);
    }
    printf("\n");


    return 0;
}

```
- 이 예제를 출력해보면 78 56 34 12 가 출력이 됩니다. 이러한 이유가 바로 리틀엔디안 때문입니다.
